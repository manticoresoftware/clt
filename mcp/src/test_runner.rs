use crate::mcp_protocol::{RunTestOutput, TestError};
use anyhow::{Context, Result};
use std::path::Path;
use std::process::Command;
use std::fs;

#[derive(Debug)]
pub struct TestRunner {
    docker_image: String,
    clt_path: String,
}

impl TestRunner {
    pub fn new(docker_image: String, clt_binary_path: Option<String>) -> Result<Self> {
        let clt_path = match clt_binary_path {
            Some(path) => {
                let path_buf = std::path::Path::new(&path);
                if !path_buf.exists() {
                    return Err(anyhow::anyhow!("CLT binary not found at specified path: {}", path));
                }
                if !path_buf.is_file() {
                    return Err(anyhow::anyhow!("Specified CLT path is not a file: {}", path));
                }
                path
            }
            None => {
                which::which("clt")
                    .context("CLT executable not found in PATH. Use --bin to specify path.")?
                    .to_string_lossy()
                    .to_string()
            }
        };

        Ok(Self {
            docker_image,
            clt_path,
        })
    }

    pub fn run_test(&self, test_path: &str) -> Result<RunTestOutput> {
        let test_path = Path::new(test_path);
        
        if !test_path.exists() {
            return Ok(RunTestOutput {
                success: false,
                errors: vec![TestError {
                    command: "file_check".to_string(),
                    expected: "Test file should exist".to_string(),
                    actual: format!("File not found: {}", test_path.display()),
                    line_number: 0,
                }],
                summary: "Test file not found".to_string(),
            });
        }

        // Execute CLT test command
        let output = Command::new(&self.clt_path)
            .args(["test", "-t", &test_path.to_string_lossy(), "-d", &self.docker_image])
            .output()
            .context("Failed to execute CLT test command")?;

        let exit_success = output.status.success();
        let stderr = String::from_utf8_lossy(&output.stderr);
        
        if exit_success {
            Ok(RunTestOutput {
                success: true,
                errors: vec![],
                summary: "Test passed successfully".to_string(),
            })
        } else {
            // Parse failures from .rep file comparison
            let errors = self.parse_test_failures_from_rep_file(test_path)?;
            let summary = if errors.is_empty() {
                format!("Test failed: {}", stderr.trim())
            } else {
                format!("Test failed with {} error(s)", errors.len())
            };

            Ok(RunTestOutput {
                success: false,
                errors,
                summary,
            })
        }
    }

    fn parse_test_failures_from_rep_file(&self, test_path: &Path) -> Result<Vec<TestError>> {
        let mut errors = Vec::new();

        // Check if .rep file exists (generated by CLT test execution)
        let rep_path = test_path.with_extension("rep");
        if !rep_path.exists() {
            // If no .rep file, create a generic error
            errors.push(TestError {
                command: "test_execution".to_string(),
                expected: "Test should generate .rep file".to_string(),
                actual: "No .rep file found after test execution".to_string(),
                line_number: 0,
            });
            return Ok(errors);
        }

        // Use CLT's cmp tool to compare .rec and .rep files
        // This ensures we use the same comparison logic as the native CLT test
        errors.extend(self.compare_rec_rep_files(test_path, &rep_path)?);

        Ok(errors)
    }

    fn compare_rec_rep_files(&self, rec_path: &Path, rep_path: &Path) -> Result<Vec<TestError>> {
        let mut errors = Vec::new();

        // Read both files
        let rec_content = fs::read_to_string(rec_path)
            .context("Failed to read .rec file")?;
        let rep_content = fs::read_to_string(rep_path)
            .context("Failed to read .rep file")?;

        // Parse sections from both files
        let rec_sections = self.parse_file_sections(&rec_content)?;
        let rep_sections = self.parse_file_sections(&rep_content)?;

        // Find pattern file for comparison (same logic as CLT)
        let pattern_file = self.find_pattern_file(rec_path);
        
        // Compare sections and identify differences
        errors.extend(self.compare_sections(&rec_sections, &rep_sections, pattern_file)?);

        Ok(errors)
    }

    fn find_pattern_file(&self, rec_path: &Path) -> Option<String> {
        // Look for .clt/patterns file in the same way CLT does
        if let Some(parent) = rec_path.parent() {
            let patterns_path = parent.join(".clt").join("patterns");
            if patterns_path.exists() {
                return Some(patterns_path.to_string_lossy().to_string());
            }
        }
        None
    }

    fn compare_sections(&self, rec_sections: &[TestSection], rep_sections: &[TestSection], pattern_file: Option<String>) -> Result<Vec<TestError>> {
        let mut errors = Vec::new();
        
        // Create pattern matcher (same as CLT uses)
        let pattern_matcher = match cmp::PatternMatcher::new(pattern_file) {
            Ok(matcher) => matcher,
            Err(e) => {
                errors.push(TestError {
                    command: "pattern_matcher_init".to_string(),
                    expected: "Pattern matcher should initialize".to_string(),
                    actual: format!("Failed to create pattern matcher: {}", e),
                    line_number: 0,
                });
                return Ok(errors);
            }
        };

        // Parse input-output pairs from both files
        let rec_pairs = self.extract_input_output_pairs(rec_sections);
        let rep_pairs = self.extract_input_output_pairs(rep_sections);

        // Compare each input-output pair
        for (rec_pair, rep_pair) in rec_pairs.iter().zip(rep_pairs.iter()) {
            // First, check if the input commands match
            if rec_pair.input_content != rep_pair.input_content {
                errors.push(TestError {
                    command: "input_mismatch".to_string(),
                    expected: rec_pair.input_content.clone(),
                    actual: rep_pair.input_content.clone(),
                    line_number: rec_pair.input_line,
                });
                continue; // Skip output comparison if input doesn't match
            }

            // Compare the outputs using pattern matcher
            if pattern_matcher.has_diff(rec_pair.output_content.clone(), rep_pair.output_content.clone()) {
                errors.push(TestError {
                    command: rec_pair.input_content.clone(), // The command that produced this output
                    expected: rec_pair.output_content.clone(),
                    actual: rep_pair.output_content.clone(),
                    line_number: rec_pair.output_line,
                });
            }
        }

        // Check for pair count mismatch
        if rec_pairs.len() != rep_pairs.len() {
            errors.push(TestError {
                command: "test_structure_mismatch".to_string(),
                expected: format!("{} input-output pairs", rec_pairs.len()),
                actual: format!("{} input-output pairs", rep_pairs.len()),
                line_number: 0,
            });
        }

        Ok(errors)
    }

    fn parse_file_sections(&self, content: &str) -> Result<Vec<TestSection>> {
        let mut sections = Vec::new();
        let mut current_section_type: Option<SectionType> = None;
        let mut current_content = Vec::new();
        let mut line_number = 1;
        let mut section_start_line = 1;

        for line in content.lines() {
            // Check if this is a section marker
            if line.starts_with("––– ") && line.ends_with(" –––") {
                // Save previous section if exists
                if let Some(ref section_type) = current_section_type {
                    let content_str = current_content.join("\n");
                    match section_type {
                        SectionType::Input => {
                            sections.push(TestSection::Input {
                                content: content_str,
                                line: section_start_line,
                            });
                        }
                        SectionType::Output => {
                            sections.push(TestSection::Output {
                                content: content_str,
                                line: section_start_line,
                            });
                        }
                    }
                    current_content.clear();
                }

                // Parse new section type
                if line.contains("input") {
                    current_section_type = Some(SectionType::Input);
                    section_start_line = line_number + 1;
                } else if line.contains("output") {
                    current_section_type = Some(SectionType::Output);
                    section_start_line = line_number + 1;
                } else {
                    // Skip other section types (comment, block, etc.)
                    current_section_type = None;
                }
            } else if current_section_type.is_some() {
                current_content.push(line.to_string());
            }
            
            line_number += 1;
        }

        // Save last section
        if let Some(ref section_type) = current_section_type {
            let content_str = current_content.join("\n");
            match section_type {
                SectionType::Input => {
                    sections.push(TestSection::Input {
                        content: content_str,
                        line: section_start_line,
                    });
                }
                SectionType::Output => {
                    sections.push(TestSection::Output {
                        content: content_str,
                        line: section_start_line,
                    });
                }
            }
        }

        Ok(sections)
    }

    #[cfg(test)]
    pub fn get_clt_path(&self) -> &str {
        &self.clt_path
    }

    fn extract_input_output_pairs(&self, sections: &[TestSection]) -> Vec<InputOutputPair> {
        let mut pairs = Vec::new();
        let mut current_input: Option<(String, usize)> = None;

        for section in sections {
            match section {
                TestSection::Input { content, line } => {
                    current_input = Some((content.clone(), *line));
                }
                TestSection::Output { content, line } => {
                    if let Some((input_content, input_line)) = current_input.take() {
                        pairs.push(InputOutputPair {
                            input_content,
                            input_line,
                            output_content: content.clone(),
                            output_line: *line,
                        });
                    }
                }
            }
        }

        pairs
    }
}

#[derive(Debug, Clone)]
struct InputOutputPair {
    input_content: String,
    input_line: usize,
    output_content: String,
    output_line: usize,
}

#[derive(Debug, Clone)]
enum TestSection {
    Input { content: String, line: usize },
    Output { content: String, line: usize },
}

#[derive(Debug, Clone)]
enum SectionType {
    Input,
    Output,
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;
    use std::io::Write;

    #[test]
    fn test_new_with_valid_bin_path() {
        // Create a temporary file to simulate a CLT binary
        let mut temp_file = NamedTempFile::new().unwrap();
        writeln!(temp_file, "#!/bin/bash\necho 'fake clt'").unwrap();
        let temp_path = temp_file.path().to_string_lossy().to_string();

        let runner = TestRunner::new(
            "test-image".to_string(),
            Some(temp_path.clone())
        ).unwrap();

        assert_eq!(runner.get_clt_path(), &temp_path);
        assert_eq!(runner.docker_image, "test-image");
    }

    #[test]
    fn test_new_with_invalid_bin_path() {
        let result = TestRunner::new(
            "test-image".to_string(),
            Some("/nonexistent/path".to_string())
        );

        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("CLT binary not found"));
    }

    #[test]
    fn test_new_with_directory_bin_path() {
        let temp_dir = tempfile::tempdir().unwrap();
        let dir_path = temp_dir.path().to_string_lossy().to_string();

        let result = TestRunner::new(
            "test-image".to_string(),
            Some(dir_path)
        );

        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("not a file"));
    }

    #[test]
    fn test_run_test_with_nonexistent_file() {
        let runner = TestRunner::new(
            "test-image".to_string(),
            None
        );

        // Skip this test if CLT is not available
        if runner.is_err() {
            return;
        }

        let runner = runner.unwrap();
        let result = runner.run_test("/nonexistent/test.rec").unwrap();

        assert!(!result.success);
        assert_eq!(result.errors.len(), 1);
        assert_eq!(result.errors[0].command, "file_check");
        assert!(result.errors[0].actual.contains("File not found"));
    }

    #[test]
    fn test_parse_file_sections() {
        let runner = TestRunner::new(
            "test-image".to_string(),
            None
        );

        // Skip this test if CLT is not available
        if runner.is_err() {
            return;
        }

        let runner = runner.unwrap();
        let content = "––– input –––\necho hello\n––– output –––\nhello\n";
        let sections = runner.parse_file_sections(content).unwrap();

        assert_eq!(sections.len(), 2);
        match &sections[0] {
            TestSection::Input { content, .. } => assert_eq!(content, "echo hello"),
            _ => panic!("Expected Input section"),
        }
        match &sections[1] {
            TestSection::Output { content, .. } => assert_eq!(content, "hello"),
            _ => panic!("Expected Output section"),
        }
    }

    #[test]
    fn test_extract_input_output_pairs() {
        let runner = TestRunner::new(
            "test-image".to_string(),
            None
        );

        // Skip this test if CLT is not available
        if runner.is_err() {
            return;
        }

        let runner = runner.unwrap();
        let sections = vec![
            TestSection::Input { content: "echo hello".to_string(), line: 1 },
            TestSection::Output { content: "hello".to_string(), line: 2 },
            TestSection::Input { content: "echo world".to_string(), line: 3 },
            TestSection::Output { content: "world".to_string(), line: 4 },
        ];

        let pairs = runner.extract_input_output_pairs(&sections);

        assert_eq!(pairs.len(), 2);
        assert_eq!(pairs[0].input_content, "echo hello");
        assert_eq!(pairs[0].output_content, "hello");
        assert_eq!(pairs[1].input_content, "echo world");
        assert_eq!(pairs[1].output_content, "world");
    }
}